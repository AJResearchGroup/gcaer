---
title: "example_tiny"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{example_tiny}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette, we'll use GCAE and its `example_tiny` example data, to train and use a GCAE neural network.

Here are the steps:

 * Setup GCAE
 * See the genetic data
 * See the GCAE model
 * Use GCAE for training

# Setup GCAE

First we determine if GCAE is installed.

To determine if GCAE is installed, we'll first load `gcaer`:

```{r setup}
library(gcaer)
```

Now `gcaer` can detect if GCAE is installed:

```{r is_gcae_installed}
good_to_go <- is_gcae_installed()
if (!good_to_go) {
  message("GCAE is not installed")
  message("Tip: use 'gcaer::install_gcae()'")
}
```

While developing this package, for now, we set `good_to_go` to `FALSE`
regardless. In that way, the GHA CI will show us the result of the test suite.

```{r}
good_to_go <- FALSE
```

These are the GCAE options:

```{r gcae_options}
gcae_options <- create_gcae_options()
gcae_options
```

The GCAE options allow a user to select a GCAE version at a custom location.

## See the genetic data

These are the `example_tiny` files supplied with GCAE:

```{r datadir}
if (good_to_go) {
  datadir <- file.path(
    gcae_options$gcae_folder,
    "example_tiny/"
  )
  list.files(datadir)
}
```
Of these files, we will use `HumanOrigins249_tiny` as the base file name:

```{r base_filename}
if (good_to_go) {
  data <- "HumanOrigins249_tiny"
  list.files(datadir, pattern = data)
}
```

We will be using the PLINK binary files, which are the `.bed`, `.bim` 
and `.fam` files.

This is the `.fam` file:

```{r read_fam_file}
n_individuals <- "[unknown]"
if (good_to_go) {
  fam_filename <- list.files(datadir, full.names = TRUE, pattern = "\\.fam$")
  fam_table <- plinkr::read_plink_fam_file(fam_filename)
  n_individuals <- nrow(fam_table)
  knitr::kable(head(fam_table))
}
```

This table shows us the `r n_individuals` individuals.

This is the `.bim` file:

```{r read_bim_file}
n_snps <- "[unknown]"
if (good_to_go) {
  bim_filename <- list.files(datadir, full.names = TRUE, pattern = "\\.bim$")
  bim_table <- plinkr::read_plink_bim_file(bim_filename)
  n_snps <- nrow(bim_table)
  knitr::kable(head(bim_table))
}
```

This table shows us the `r n_snps` SNPs.

This is the `.bed` file:

```{r read_bed_file}
if (good_to_go) {
  bed_filename <- list.files(
    datadir,
    full.names = TRUE,
    pattern = "\\.bed$"
  )
  bed_table <- plinkr::read_plink_bed_file_from_files(
    bed_filename = bed_filename,
    bim_filename = bim_filename,
    fam_filename = fam_filename
  )
  testthat::expect_equal(n_individuals, ncol(bed_table))
  testthat::expect_equal(n_snps, nrow(bed_table))
  knitr::kable(head(bed_table[, 1:10]))
}
```

## See the GCAE setup

In this tutorial, we'll be using a standard GCAE setup.

```{r gcae_setup}
if (good_to_go) {
  gcae_setup <- create_gcae_setup(
    datadir = datadir,
    data = data
  )
  names(gcae_setup)
}
```

The GCAE setup contains the GCAE setup, such as the auto-encoder's
specification, training options and data options:

 * `model_id`: the setup of the auto-encoder
 * `train_opts_id`: the setup of the training of the auto-encoder
 * `data_opts_id`: the setup of the ?file storage? of the auto-encoder

Here we take a look at how each of these is set up.

### The model ID

```{r model_id}
if (good_to_go) {
  model_filename <- get_gcae_model_filename(gcae_setup$model_id)
  testthat::expect_true(file.exists(model_filename))
  readr::read_lines(model_filename)
}
```

### train_opts_id

```{r train_opts_id}
if (good_to_go) {
  train_opts_filename <- get_gcae_train_opts_filename(gcae_setup$train_opts_id)
  testthat::expect_true(file.exists(train_opts_filename))
  readr::read_lines(train_opts_filename)
}
```

### data_opts_id

```{r data_opts_id}
if (good_to_go) {
  data_opts_filename <- get_gcae_data_opts_filename(gcae_setup$data_opts_id)
  testthat::expect_true(file.exists(data_opts_filename))
  readr::read_lines(data_opts_filename)
}
```

## Training

Here we train the auto-encoder:

```{r gcae_train,cache=FALSE}
if (good_to_go) {
  epochs <- 3
  train_filenames <- gcae_train(
    gcae_setup = gcae_setup,
    epochs = epochs,
    save_interval = 1
  )
}
```

```{r parse_train_filenames,cache=FALSE}
if (good_to_go) {
  train_results <- parse_train_filenames(train_filenames)
}
```

Training times:

```{r}
if (good_to_go) {
  ggplot2::ggplot(
    train_results$train_times_table,
    ggplot2::aes(x = epoch, y = train_times_sec)
  ) + ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0.0, 1.0))
}
```

Losses from training:

```{r}
if (good_to_go) {
  ggplot2::ggplot(
    train_results$losses_from_train_t_table,
    ggplot2::aes(x = epoch, y = losses_from_train_t)
  ) + ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0.0, 1.0))
}
```

Losses from validation:

```{r}
if (good_to_go) {
  ggplot2::ggplot(
    train_results$losses_from_train_v_table,
    ggplot2::aes(x = epoch, y = losses_from_train_v)
  ) + ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0.0, 1.0))
}
```

## Project

```{r gcae_project,cache=FALSE}
if (good_to_go) {
  superpops <- file.path(datadir, "HO_superpopulations")
  project_filenames <- gcae_project(
    superpops = superpops,
    gcae_setup = gcae_setup
  )
}
```

Parse the results:

```{r cache=FALSE}
if (good_to_go) {
  project_results <- parse_project_files(project_filenames)
}
```

Show the results:

```{r cache=FALSE}
if (good_to_go) {
  ggplot2::ggplot(
    project_results$losses_from_project_table,
    ggplot2::aes(x = epoch, y = losses_from_project)
  ) + ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0.0, 1.0))
}
```

```{r cache=FALSE}
if (good_to_go) {
  ggplot2::ggplot(
    project_results$genotype_concordances_table,
    ggplot2::aes(x = epoch, y = genotype_concordances)
  ) + ggplot2::geom_line() +
    ggplot2::scale_y_continuous(limits = c(0.0, 1.0))
}
```

## Show neural network's performance

Here we let GCAE create all plots:

```{r gcae_plot,cache=FALSE}
if (good_to_go) {
  plot_filenames <- gcae_plot(
    superpops = superpops,
    gcae_setup = gcae_setup,
    gcae_options = gcae_options
  )
}
```

These plots are 8 PDFs and 2 CSVs. 

Here we collect the PDF filenames:

```{r gcae_plot_collect_pdf_filenames}
if (good_to_go) {
  pdf_plot_filenames <- stringr::str_subset(
    string = plot_filenames,
    pattern = "\\.pdf$"
  )
  testthat::expect_true(length(pdf_plot_filenames) >= epochs + 5)
}
```

We have to plot the 8 PDFs one-by-one
as a for-loop won't work here:

```{r gcae_plot_1}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[1]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_2}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[2]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_3}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[3]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_4}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[4]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_5}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[5]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_6}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[6]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_7}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[7]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

```{r gcae_plot_8}
if (good_to_go) {
  pdf_plot_filename <- pdf_plot_filenames[8]
  cat(basename(pdf_plot_filename))
  bitmap <- pdftools::pdf_render_page(pdf_plot_filename, page = 1)
  temp_png_filename <- tempfile(fileext = ".png")
  png::writePNG(bitmap, temp_png_filename)
  knitr::include_graphics(temp_png_filename)
}
```

Here we collect the two CSV filenames:

```{r gcae_plot_collect_csv_filenames}
if (good_to_go) {
  csv_plot_filenames <- stringr::str_subset(
    string = plot_filenames,
    pattern = "\\.csv$"
  )
  testthat::expect_equal(length(csv_plot_filenames), 2)
}
```

Now the first CSVs:

```{r gcae_plot_csv_1}
if (good_to_go) {
  csv_plot_filename <- csv_plot_filenames[1]
  cat(basename(csv_plot_filename))
  knitr::kable(head(readr::read_csv(csv_plot_filename)))
}
```

Now the second CSVs:

```{r gcae_plot_csv_2}
if (good_to_go) {
  csv_plot_filename <- csv_plot_filenames[2]
  cat(basename(csv_plot_filename))
  knitr::kable(head(readr::read_csv(csv_plot_filename)))
}
```
